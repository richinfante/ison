{"version":3,"sources":["parser.js"],"names":["types","Date","Object","Array","Number","funcs","Int","parseInt","Float","Boolean","_Boolean","_x","apply","this","arguments","toString","Map","Set","RegExp","Buffer","from","TOKEN_COMMA","TOKEN_COLON","TOKEN_INFINITY","TOKEN_NAN","TOKEN_TRUE","TOKEN_FALSE","TOKEN_NULL","TOKEN_LBRACE","Parser","_classCallCheck","TOKEN_WS","TOKEN_STRING_START","TOKEN_IDENTIFIER","_createClass","key","value","stored","NaN","printError","skip","identifier","is","current","next","charCodeAt","num","TOKEN_NUMBER_START","indexOf","substr","parseFloat","start","out","array","parseNext","TOKEN_RPAREN","push","TOKEN_RBRACKET","object","parseString","parseIdentifier","TOKEN_RBRACE","debug","parseObject","parseNumber","args","name","Function","prototype","bind","concat","_toConsumableArray","length","newInstance","fromIdentifier","token","test","cur","TOKEN_LPAREN","string","strict","undefined","count","Infinity","peek","seek","error","l_bound","u_bound","Error","substring","replace","padStart","TOKEN_NEWLINE","get","TOKEN_LBRACKET","stringifyKey","stringify","getTime","String","map","join","constructor","entries","source","flags","item","isNaN","_typeof","exported_funcs","parse","module","exports","window"],"mappings":"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","file":"parser.js","sourcesContent":["/** \n * PV3 Experimental ISON Parser\n * This is designed to be ported into other languages, such as rust.\n * It will run faster there.\n *\n *\n * This parser is cursor based.\n * We have a finite set of tokens we should encounter at a specific index.\n * We can then use those to determine what to do next.\n * \n * For in-console debugging, set DEBUG env variable\n * For in-browser debugging, set DEBUG variable to true.\n */\n\n\n(function() {\n\n  \n  // Type constructors\n  // Called with \"new\" to create an instance\n  const types = {\n    'Date': Date,\n    'Object': Object,\n    'Array': Array,\n    'Number': Number\n  }\n\n  // Functions\n  // Called normally with arguments to create instance.\n  const funcs = {\n    'Int': parseInt,\n    'Float': parseFloat,\n    'Boolean': el => new Boolean(el.toLowerCase() == 'true')\n  }\n\n  // Detect Map support\n  if (typeof Map != \"undefined\") {\n    types['Map'] = Map\n  }\n\n  // Detect Set support\n  if (typeof Set != \"undefined\") {\n    types['Set'] = Set\n  }\n\n  // Detect RegExp support\n  if (typeof RegExp != \"undefined\") {\n    types['RegExp'] = RegExp\n  }\n\n  // Detect if buffer.from is available.\n  if (typeof Buffer != \"undefined\") {\n    // If it is, check if Buffer.from() is supported.\n    if (typeof Buffer.from === \"function\") {\n      funcs['Buffer'] = Buffer.from\n    } else {\n      // Fallback to constructor.\n      types['Buffer'] = Buffer\n    }\n  }\n\n\n  function newInstance(name, args) {\n    debug.types('newInstance', name, args)\n\n    // Create a new instance using a constructor\n    if (types[name]) {\n      return new types[name](...args)\n    }\n    \n    // Create a new instance using functions\n    if (funcs[name]) {\n      return funcs[name](...args)\n    }\n    \n    \n    if (args.length == 1) {\n       return args[0]\n     } else {\n       return args\n     }\n    \n  }\n\n  // Tokens\n  const TOKEN_INFINITY = 'Infinity'\n  const TOKEN_NAN      = 'NaN'\n  const TOKEN_TRUE     = 'true'\n  const TOKEN_FALSE    = 'false'\n  const TOKEN_NULL     = 'null'\n  const TOKEN_LBRACE   = '{'\n  const TOKEN_RBRACE   = '}'\n  const TOKEN_LBRACKET = '['\n  const TOKEN_RBRACKET = ']'\n  const TOKEN_LPAREN   = '('\n  const TOKEN_RPAREN   = ')'\n  const TOKEN_SQUOTE   = `'`\n  const TOKEN_DQUOTE   = `\"`\n  const TOKEN_COMMA    = `,`\n  const TOKEN_COLON    = /[:=]/\n  const TOKEN_WS       = /[ \\n\\t]/\n  const TOKEN_STRING_START = /[\"']/\n  const TOKEN_IDENTIFIER = /[a-z0-9_]/i\n  const TOKEN_IDENTIFIER_START = /[a-z_]/i\n  const TOKEN_NUMBER_START = /[+0-9\\-]/\n  const TOKEN_NUMBER = /[0-9xbo\\.+\\-a-f]/i\n  const TOKEN_ESCAPE = '\\\\'\n  const TOKEN_NEWLINE = '\\n'\n  const TOKEN_LINE_COMMENT = '//'\n  const TOKEN_BLOCK_COMMENT_START = '/*'\n  const TOKEN_BLOCK_COMMENT_END = '*/'\n\n\n  class Parser {\n    constructor(string) {\n      this.cur = 0\n      this.string = string\n      this.stored = ''\n    }\n\n    /**\n     * Convert an identifier into a primitive value.\n     * @param  {string} value a string representing some predefined value.\n     * @return {Any}       the represented value\n     * @throws {Error} If the value is not found.\n     */\n    fromIdentifier(value) {\n\n      if (value == TOKEN_NULL) { \n        return null\n      }\n\n      if (value == TOKEN_INFINITY) { \n        return Infinity\n      }\n\n      if (value == TOKEN_NAN) { \n        return NaN\n      }\n\n      if (value == TOKEN_TRUE) { \n        return true\n      }\n\n      if (value == TOKEN_FALSE) { \n        return false\n      }\n\n      this.printError(`Unknown Identifier: \"${value}\"`)\n    }\n\n    /**\n     * Parse an identifier.\n     * @return {[type]} an identifier string.\n     */\n    parseIdentifier() {\n      this.skip(TOKEN_WS)\n\n      let identifier = ''\n\n      if (this.is(TOKEN_IDENTIFIER_START)) {\n        while (this.is(TOKEN_IDENTIFIER)) {\n          identifier += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      }\n\n      return identifier\n    }\n\n    /**\n     * Parse an identifier. These should be valid JS object keys.\n     * @return {number} The number that was parsed.\n     */\n    parseNumber() {\n      this.skip(TOKEN_WS)\n\n      let num = ''\n      if (this.is(TOKEN_NUMBER_START)) {\n        while (this.is(TOKEN_NUMBER)) {\n          num += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      } \n\n      if(num.indexOf('0x') == 0) {\n        return parseInt(num.substr(2), 16)\n      } else if(num.indexOf('0b') == 0) {\n        return parseInt(num.substr(2), 2)\n      } else if(num.indexOf('0o') == 0) {\n        return parseInt(num.substr(2), 8)\n      }\n\n      return parseFloat(num)\n    }\n\n    /**\n     * Parse a string\n     * @return {string} the string that was parsed.\n     */\n    parseString() {\n      debug.string('Parsing String.')\n      if(!this.is(TOKEN_STRING_START)) {\n        this.printError('Invalid String start token')\n      }\n      \n      let start = this.current\n      this.skip(TOKEN_STRING_START, true, 1)\n      let out = ''\n\n\n      debug.string(`Entered string with \"${start}\" (${start.charCodeAt(0)})`)\n      \n      while(true) {\n        debug.string(`Have \"${this.current}\" (${this.current.charCodeAt(0)})`)\n        if(this.is(TOKEN_ESCAPE)) {\n          out += this.next()\n          debug.string('Got escape for', this.current)\n        } else if(this.is(start)) {\n          debug.string('End of string')\n          break\n        } else {\n          out += this.current\n          debug.string('Append', this.current)\n        }\n\n        this.next()\n      }\n\n      this.skip(TOKEN_STRING_START, true, 1)\n\n      debug.string(`output: \"${out}\"`)\n      return out\n    }\n\n    /**\n     * Parse an argument list\n     * @return {array} an array containing all the arguments.\n     */\n    parseArguments() {\n      this.skip(TOKEN_LPAREN, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RPAREN)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RPAREN)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RPAREN, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an array.\n     * @return {array} returns array items\n     */\n    parseArray() {\n      this.skip(TOKEN_LBRACKET, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RBRACKET)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACKET)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RBRACKET, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an object notation block.\n     * @return {object} The represented object.\n     */\n    parseObject() {\n\n      debug.object('entering object.')\n\n      this.skip(TOKEN_LBRACE, true, 1)\n      this.skip(TOKEN_WS)\n\n      let object = {}\n\n      while(!this.is(TOKEN_RBRACE)) {\n        let key = null\n\n        this.skip(TOKEN_WS)\n\n        debug.object('parsing key')\n\n        // Allowing quoted keys, use quote opt. to figure out which.\n        if (this.is(TOKEN_STRING_START)) {\n          key = this.parseString()\n        } else if (this.is(TOKEN_NUMBER_START)) {\n          key = this.parseNumber()\n        } else {\n          key = this.parseIdentifier()\n        }\n\n        // Skip separator and WS\n        this.skip(TOKEN_WS)\n        this.skip(TOKEN_COLON, true, 1)\n        this.skip(TOKEN_WS)\n\n        debug.object('got key', key)\n\n        // Value can be anything, go next.\n        let value = this.parseNext()\n\n        debug.object('got value', value)\n\n        // Save the key\n        object[key] = value\n\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACE)) {\n          break\n        } else {\n          this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)}), looking for COMMA or RBRACE.`)\n        }\n      }\n\n      this.skip(TOKEN_RBRACE, true, 1)\n\n      return object\n    }\n\n    /**\n     * Parse the next item.\n     * This is used to parse a value of any type \n     * @return {any} The value\n     */\n    parseNext() {\n      debug.log('parse next!')\n      this.skip(TOKEN_WS)\n\n      if (this.is(TOKEN_LBRACE)) {\n        return this.parseObject()\n      } else if (this.is(TOKEN_LBRACKET)) {\n        return this.parseArray()\n      } else if (this.is(TOKEN_LPAREN)) {\n        return this.parseArguments()\n      } else if (this.is(TOKEN_NUMBER_START)) {\n        return this.parseNumber()\n      } else if (this.is(TOKEN_STRING_START)) {\n        return this.parseString()\n      } else if (this.is(TOKEN_IDENTIFIER_START)){\n        let identifier = this.parseIdentifier()\n        if(this.is(TOKEN_LPAREN)) {\n          let args = this.parseArguments()\n          return newInstance(identifier, args)\n        } else {\n          return this.fromIdentifier(identifier)\n        }\n      } else {\n        this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)})`)\n      }\n    }\n\n    /**\n     * Check if the current character is a token\n     * @param  {RegExp|string}  token a token description\n     * @return {Boolean}       does it match the current?\n     */\n    is(token) {\n      if(token instanceof RegExp) {\n        return token.test(this.current)\n      } else {\n        return this.current == token\n      }\n    }\n\n    /**\n     * Get the character under the cursor\n     * @return {string} the character\n     */\n    get current() {\n      return this.string[this.cur]\n    }\n\n    /**\n     * Advance the cursor and get the next value\n     * @throws {Error} If we need a next character and we found EOF.\n     * @return {string} the next character\n     */\n    next () {\n      this.cur += 1\n      if (this.cur > this.string.length) {\n        this.printError('Unexpected EOF!')\n      }\n      return this.current\n    }\n\n    /**\n     * Returns the next character in the input string.\n     * @return {string} next input character\n     */\n    peek() {\n      return this.string[this.cur + 1]\n    }\n\n\n    /**\n     * Seek forward in the input for a specific token\n     * @param  {RegExp|string} token token to find.\n     */\n    seek (token) {\n      while(!this.is(token)) {\n        this.next()\n        debug.skip('(seek) skipping', this.current)\n      }\n    }\n\n    /**\n     * Skip matching tokens.\n     * @param  {RegExp|String}  token  token to skip\n     * @param  {Boolean} strict should we fail if this cannot be found?\n     * @param  {Number}  count  skip a certain amount of tokens.\n     */\n    skip(token, strict=false, count=Infinity) {\n      debug.skip('skipping', token)\n      let old = this.cur\n\n      // If we're in strict mode, fail immediately.\n      if (strict && !this.is(token)) {\n        this.printError(`expected token \"${token}\" got \"${this.current}\"!`)\n      }\n\n      // While it matches, continue.\n      while(this.is(token) && count > 0) {\n        this.cur += 1\n        count -= 1\n      }\n\n      debug.skip('skipped ahead', this.cur - old)\n\n      // If we're skipping whitespace, \n      // Perform a skip for comments as well, if the token matches.\n      if (token == TOKEN_WS) {\n        debug.skip('check comment seek')\n\n        // If we're on a line comment\n        if (this.current + this.peek() == TOKEN_LINE_COMMENT) {\n          // Seek past it\n          this.seek(TOKEN_NEWLINE)\n        }\n\n        // If we're on a block comment\n        if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_START) {\n          \n          while(true) {\n            // Seek to the next '*'  \n            this.seek('*')\n\n            // If it makes up a comment end, break.\n            if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_END) {\n              break\n            } else {\n              // Otherwise, continue.\n              this.next()\n            }\n          }\n\n          // Skip past the end comment.\n          this.next()\n          this.next()\n        }\n\n        // If it's still whitespace, skip.\n        // TOKEN_WS can only handle one comment at a time.\n        if (this.is(TOKEN_WS)) {\n          this.skip(TOKEN_WS)\n        }\n      }\n    }\n\n    /**\n     * Throw an error, internal use function.\n     * throws an error with source printout, error description.\n     * @throws {Error} If true\n     * @param  {String} error error description\n     */\n    printError(error='Unknown Error') {\n      let current = this.cur\n      let l_bound = current - 10\n      if(l_bound < 0) {\n        l_bound = 0\n      }\n\n      let u_bound = current + 10\n      if (u_bound >= this.string.length) {\n        u_bound = this.string.length - 1\n      }\n\n      let count = current - l_bound\n\n      throw new Error(`Could not parse input.\n${this.string.substring(l_bound, u_bound).replace(/\\n/g, ' ')}\n${'^'.padStart(count + 1)}\n${error}\nat input: ${this.cur}`)\n    }\n  }\n\n  /**\n   * Stringify a key.\n   * This may add quotes if it does not conform to bare key requirements.\n   * \n   * @param  {string} key the object key\n   * @return {string}     string representing the key.\n   */\n  function stringifyKey(key) {\n    if(/^[a-zA-Z_][_a-zA-Z0-9]*$/.test(key)) {\n      return key\n    } else {\n      return stringify(key)\n    }\n  }\n\n\n  /**\n   * Stringify an object, recursively\n   * @param  {object} object to stringify\n   * @return {string}        string representation\n   */\n  function stringify(object) {\n    if (object instanceof Date) {\n      // Serialize dates\n      return `Date(${object.getTime()})`\n    } else if (typeof object == 'string' || object instanceof String) {\n      // Place into double quoted (escaped) strings\n      return `\"${object.replace(/\"/g, '\\\\\"')}\"`\n    } else if (object instanceof Array) {\n      // Join the stringification of children\n      return `[${object.map(stringify).join(',')}]`\n    } else if(object.constructor.name == 'Set') {\n      return `Set(${stringify(Array.from(object))})`\n    } else if(object.constructor.name == 'Map') {\n      return `Map(${stringify(Array.from(object.entries()))})`\n    } else if (typeof Buffer != \"undefined\" && object instanceof Buffer) {\n      return `Buffer([${[...object]}])`\n    } else if(object instanceof RegExp){\n      return `RegExp(${stringify(object.source)}, ${stringify(object.flags)})`\n    } else if (typeof object == 'boolean') {\n      return `${object}`\n    } else if (object instanceof Object) {\n      let name = object['$type'] || object.constructor.name\n\n      delete object['$type']\n\n      // Join key value pairs. Possibly use $type or constructor name\n      if (name == 'Object') {\n        return `{${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}}`\n      } else {\n        return `${name}({${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}})`\n      }\n    } else if (isNaN(object)) {\n      return 'NaN'\n    } else if (typeof object == 'number') {\n      // Number\n      return `${object}`\n    } else {\n      console.log(object, typeof object)\n      throw new Error('Stringify Error!')\n    }\n  }\n\n  /**\n   * Parse a string using the parser.\n   * @param  {ison string} string ison formatted string representing data.\n   * @throws {Error} If the data is incorrectly formatted.\n   * @return {Any}        the represented data\n   */\n  function parse(string) {\n    let p = new Parser(string)\n    let result = p.parseNext()\n    return result\n  }\n\n  // Module shim.\n  var exported_funcs = { parse, stringify }\n\n  if(typeof module != \"undefined\") {\n    module.exports = exported_funcs\n  } else if (typeof window != \"undefined\") {\n    window['ISON'] = exported_funcs\n  }\n\n})();"]}