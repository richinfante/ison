{"version":3,"sources":["parser.js"],"names":["types","Date","Object","Array","Number","funcs","Int","parseInt","Float","Boolean","_Boolean","_x","apply","this","arguments","toString","Map","Set","RegExp","Buffer","from","TOKEN_COMMA","TOKEN_COLON","TOKEN_INFINITY","TOKEN_NAN","TOKEN_TRUE","TOKEN_FALSE","TOKEN_NULL","TOKEN_LBRACE","Parser","string","_classCallCheck","cur","value","stored","_createClass","key","skip","TOKEN_WS","is","TOKEN_IDENTIFIER_START","TOKEN_IDENTIFIER","identifier","current","printError","charCodeAt","num","next","indexOf","substr","parseFloat","start","TOKEN_STRING_START","out","TOKEN_ESCAPE","debug","array","parseNext","push","parseString","TOKEN_NUMBER_START","parseNumber","TOKEN_RBRACKET","object","parseObject","parseArray","parseArguments","TOKEN_RBRACE","args","name","Function","prototype","bind","concat","_toConsumableArray","length","newInstance","TOKEN_NUMBER","TOKEN_BLOCK_COMMENT_START","TOKEN_BLOCK_COMMENT_END","Error","fromIdentifier","token","ret","test","error","l_bound","u_bound","count","substring","padStart","console","strict","undefined","Infinity","currentMatches","peek","get","TOKEN_LBRACKET","stringify","getTime","TOKEN_NEWLINE","String","replace","map","join","constructor","seek","entries","source","flags","item","stringifyKey","isNaN","_typeof","parse","module","exports","window"],"mappings":"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","file":"parser.js","sourcesContent":["/** \n * PV3 Experimental ISON Parser\n * This is designed to be ported into other languages, such as rust.\n * It will run faster there.\n *\n *\n * This parser is cursor based.\n * We have a finite set of tokens we should encounter at a specific index.\n * We can then use those to determine what to do next.\n * \n * For in-console debugging, set DEBUG env variable\n * For in-browser debugging, set DEBUG variable to true.\n */\n\n\n(function() {\n\n  \n  // Type constructors\n  // Called with \"new\" to create an instance\n  const types = {\n    'Date': Date,\n    'Object': Object,\n    'Array': Array,\n    'Number': Number\n  }\n\n  // Functions\n  // Called normally with arguments to create instance.\n  const funcs = {\n    'Int': parseInt,\n    'Float': parseFloat,\n    'Boolean': el => new Boolean(el.toLowerCase() == 'true')\n  }\n\n  // Detect Map support\n  if (typeof Map != \"undefined\") {\n    types['Map'] = Map\n  }\n\n  // Detect Set support\n  if (typeof Set != \"undefined\") {\n    types['Set'] = Set\n  }\n\n  // Detect RegExp support\n  if (typeof RegExp != \"undefined\") {\n    types['RegExp'] = RegExp\n  }\n\n  // Detect if buffer.from is available.\n  if (typeof Buffer != \"undefined\") {\n    // If it is, check if Buffer.from() is supported.\n    if (typeof Buffer.from === \"function\") {\n      funcs['Buffer'] = Buffer.from\n    } else {\n      // Fallback to constructor.\n      types['Buffer'] = Buffer\n    }\n  }\n\n\n  function newInstance(name, args) {\n    debug.types('newInstance', name, args)\n\n    // Create a new instance using a constructor\n    if (types[name]) {\n      return new types[name](...args)\n    }\n    \n    // Create a new instance using functions\n    if (funcs[name]) {\n      return funcs[name](...args)\n    }\n    \n    \n    if (args.length == 1) {\n       return args[0]\n     } else {\n       return args\n     }\n    \n  }\n\n  // Tokens\n  const TOKEN_INFINITY = 'Infinity'\n  const TOKEN_NAN      = 'NaN'\n  const TOKEN_TRUE     = 'true'\n  const TOKEN_FALSE    = 'false'\n  const TOKEN_NULL     = 'null'\n  const TOKEN_LBRACE   = '{'\n  const TOKEN_RBRACE   = '}'\n  const TOKEN_LBRACKET = '['\n  const TOKEN_RBRACKET = ']'\n  const TOKEN_LPAREN   = '('\n  const TOKEN_RPAREN   = ')'\n  const TOKEN_SQUOTE   = `'`\n  const TOKEN_DQUOTE   = `\"`\n  const TOKEN_COMMA    = `,`\n  const TOKEN_COLON    = /[:=]/\n  const TOKEN_WS       = /[ \\n\\t]/\n  const TOKEN_STRING_START = /[\"']/\n  const TOKEN_IDENTIFIER = /[a-z0-9_]/i\n  const TOKEN_IDENTIFIER_START = /[a-z_]/i\n  const TOKEN_NUMBER_START = /[+0-9\\-]/\n  const TOKEN_NUMBER = /[0-9xbo\\.+\\-a-f]/i\n  const TOKEN_ESCAPE = '\\\\'\n  const TOKEN_NEWLINE = '\\n'\n  const TOKEN_LINE_COMMENT = '//'\n  const TOKEN_BLOCK_COMMENT_START = '/*'\n  const TOKEN_BLOCK_COMMENT_END = '*/'\n\n\n  // Convert an identifier into a primitive value.\n  function fromIdentifier(value) {\n\n    if (value == TOKEN_NULL) { \n      return null\n    }\n\n    if (value == TOKEN_INFINITY) { \n      return Infinity\n    }\n\n    if (value == TOKEN_NAN) { \n      return NaN\n    }\n\n    if (value == TOKEN_TRUE) { \n      return true\n    }\n\n    if (value == TOKEN_FALSE) { \n      return false\n    }\n\n    throw new Error('Unknown Identifier' + string)\n  }\n\n  class Parser {\n    constructor(string) {\n      this.cur = 0\n      this.string = string\n      this.stored = ''\n    }\n\n    /**\n     * Parse an identifier.\n     * @return {[type]} an identifier string.\n     */\n    parseIdentifier() {\n      this.skip(TOKEN_WS)\n\n      let identifier = ''\n\n      if (this.is(TOKEN_IDENTIFIER_START)) {\n        while (this.is(TOKEN_IDENTIFIER)) {\n          identifier += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      }\n\n      return identifier\n    }\n\n    /**\n     * Parse an identifier. These should be valid JS object keys.\n     * @return {number} The number that was parsed.\n     */\n    parseNumber() {\n      this.skip(TOKEN_WS)\n\n      let num = ''\n      if (this.is(TOKEN_NUMBER_START)) {\n        while (this.is(TOKEN_NUMBER)) {\n          num += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      } \n\n      if(num.indexOf('0x') == 0) {\n        return parseInt(num.substr(2), 16)\n      } else if(num.indexOf('0b') == 0) {\n        return parseInt(num.substr(2), 2)\n      } else if(num.indexOf('0o') == 0) {\n        return parseInt(num.substr(2), 8)\n      }\n\n      return parseFloat(num)\n    }\n\n    /**\n     * Parse a string\n     * @return {string} the string that was parsed.\n     */\n    parseString() {\n      debug.string('Parsing String.')\n      if(!this.is(TOKEN_STRING_START)) {\n        this.printError('Invalid String start token')\n      }\n      \n      let start = this.current\n      this.skip(TOKEN_STRING_START, true, 1)\n      let out = ''\n\n\n      debug.string(`Entered string with \"${start}\" (${start.charCodeAt(0)})`)\n      \n      while(true) {\n        debug.string(`Have \"${this.current}\" (${this.current.charCodeAt(0)})`)\n        if(this.is(TOKEN_ESCAPE)) {\n          out += this.next()\n          debug.string('Got escape for', this.current)\n        } else if(this.is(start)) {\n          debug.string('End of string')\n          break\n        } else {\n          out += this.current\n          debug.string('Append', this.current)\n        }\n\n        this.next()\n      }\n\n      this.skip(TOKEN_STRING_START, true, 1)\n\n      debug.string(`output: \"${out}\"`)\n      return out\n    }\n\n    /**\n     * Parse an argument list\n     * @return {array} an array containing all the arguments.\n     */\n    parseArguments() {\n      this.skip(TOKEN_LPAREN, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RPAREN)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RPAREN)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RPAREN, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an array.\n     * @return {array} returns array items\n     */\n    parseArray() {\n      this.skip(TOKEN_LBRACKET, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RBRACKET)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACKET)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RBRACKET, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an object notation block.\n     * @return {object} The represented object.\n     */\n    parseObject() {\n\n      debug.object('entering object.')\n\n      this.skip(TOKEN_LBRACE, true, 1)\n      this.skip(TOKEN_WS)\n\n      let object = {}\n\n      while(!this.is(TOKEN_RBRACE)) {\n        let key = null\n\n        this.skip(TOKEN_WS)\n\n        debug.object('parsing key')\n\n        // Allowing quoted keys, use quote opt. to figure out which.\n        if (this.is(TOKEN_STRING_START)) {\n          key = this.parseString()\n        } else if (this.is(TOKEN_NUMBER_START)) {\n          key = this.parseNumber()\n        } else {\n          key = this.parseIdentifier()\n        }\n\n        // Skip separator and WS\n        this.skip(TOKEN_WS)\n        this.skip(TOKEN_COLON, true, 1)\n        this.skip(TOKEN_WS)\n\n        debug.object('got key', key)\n\n        // Value can be anything, go next.\n        let value = this.parseNext()\n\n        debug.object('got value', value)\n\n        // Save the key\n        object[key] = value\n\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACE)) {\n          break\n        } else {\n          this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)}), looking for COMMA or RBRACE.`)\n        }\n      }\n\n      this.skip(TOKEN_RBRACE, true, 1)\n\n      return object\n    }\n\n    /**\n     * Parse the next item.\n     * This is used to parse a value of any type \n     * @return {any} The value\n     */\n    parseNext() {\n      debug.log('parse next!')\n      this.skip(TOKEN_WS)\n\n      if (this.is(TOKEN_LBRACE)) {\n        return this.parseObject()\n      } else if (this.is(TOKEN_LBRACKET)) {\n        return this.parseArray()\n      } else if (this.is(TOKEN_LPAREN)) {\n        return this.parseArguments()\n      } else if (this.is(TOKEN_NUMBER_START)) {\n        return this.parseNumber()\n      } else if (this.is(TOKEN_STRING_START)) {\n        return this.parseString()\n      } else if (this.is(TOKEN_IDENTIFIER_START)){\n        let identifier = this.parseIdentifier()\n        if(this.is(TOKEN_LPAREN)) {\n          let args = this.parseArguments()\n          return newInstance(identifier, args)\n        } else {\n          return fromIdentifier(identifier)\n        }\n      } else {\n        this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)})`)\n      }\n    }\n\n    is(token) {\n      let ret = false\n\n      if(token instanceof RegExp) {\n        ret = token.test(this.current)\n      } else {\n        ret = this.current == token\n      }\n\n      debug.log('check is', this.current, token, ret)\n      \n      return ret\n    }\n\n    get current() {\n      return this.string[this.cur]\n    }\n\n\n    printError(error='Unknown Error') {\n      let current = this.cur\n      let l_bound = current - 10\n      if(l_bound < 0) {\n        l_bound = 0\n      }\n\n      let u_bound = current + 10\n      if (u_bound >= this.string.length) {\n        u_bound = this.string.length - 1\n      }\n\n      let count = current - l_bound\n      console.log(this.string.substring(l_bound, u_bound).replace(/\\n/g, ' '))\n      console.log('^'.padStart(count + 1))\n      console.log('index:', this.cur)\n      \n      throw new Error(error)\n    }\n\n    next () {\n      this.cur += 1\n      if (this.cur > this.string.length) {\n        this.printError('Unexpected EOF!')\n      }\n      return this.current\n    }\n\n    peek() {\n      return this.string[this.cur + 1]\n    }\n\n    clear() {\n      this.stored = ''\n    }\n\n    getParsed() {\n      return this.stored\n    }\n\n\n    seek (token) {\n      while(!this.currentMatches(token)) {\n        this.next()\n        debug.skip('(seek) skipping', this.current)\n      }\n    }\n\n    currentMatches(token) {\n      if (token instanceof RegExp) {\n        return token.test(this.current)\n      } else {\n        return this.current == token\n      }\n    }\n\n    // SKIP any number of tokens.\n    skip(token, strict=false, count=Infinity) {\n      debug.skip('skipping', token)\n      let old = this.cur\n\n      // If we're in strict mode, fail immediately.\n      if (strict && !this.currentMatches(token)) {\n        this.printError(`expected token \"${token}\" got \"${this.current}\"!`)\n      }\n\n      // While it matches, continue.\n      while(this.currentMatches(token) && count > 0) {\n        this.cur += 1\n        count -= 1\n      }\n\n      debug.skip('skipped ahead', this.cur - old)\n\n      // If we're skipping whitespace, \n      // Perform a skip for comments as well, if the token matches.\n      if (token == TOKEN_WS) {\n        debug.skip('check comment seek')\n\n        // If we're on a line comment\n        if (this.current + this.peek() == TOKEN_LINE_COMMENT) {\n          // Seek past it\n          this.seek(TOKEN_NEWLINE)\n        }\n\n        // If we're on a block comment\n        if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_START) {\n          \n          while(true) {\n            // Seek to the next '*'  \n            this.seek('*')\n\n            // If it makes up a comment end, break.\n            if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_END) {\n              break\n            } else {\n              // Otherwise, continue.\n              this.next()\n            }\n          }\n\n          // Skip past the end comment.\n          this.next()\n          this.next()\n        }\n\n        // If it's still whitespace, skip.\n        // TOKEN_WS can only handle one comment at a time.\n        if (this.is(TOKEN_WS)) {\n          this.skip(TOKEN_WS)\n        }\n      }\n    }\n  }\n\n  function stringifyKey(key) {\n    if(/^[a-zA-Z_][_a-zA-Z0-9]*$/.test(key)) {\n      return key\n    } else {\n      return stringify(key)\n    }\n  }\n\n\n  function stringify(object) {\n    if (object instanceof Date) {\n      // Serialize dates\n      return `Date(${object.getTime()})`\n    } else if (typeof object == 'string' || object instanceof String) {\n      // Place into double quoted (escaped) strings\n      return `\"${object.replace(/\"/g, '\\\\\"')}\"`\n    } else if (object instanceof Array) {\n      // Join the stringification of children\n      return `[${object.map(stringify).join(',')}]`\n    } else if(object.constructor.name == 'Set') {\n      return `Set(${stringify(Array.from(object))})`\n    } else if(object.constructor.name == 'Map') {\n      return `Map(${stringify(Array.from(object.entries()))})`\n    } else if (typeof Buffer != \"undefined\" && object instanceof Buffer) {\n      return `Buffer([${[...object]}])`\n    } else if(object instanceof RegExp){\n      return `RegExp(${stringify(object.source)}, ${stringify(object.flags)})`\n    } else if (typeof object == 'boolean') {\n      return `${object}`\n    } else if (object instanceof Object) {\n      let name = object['$type'] || object.constructor.name\n\n      delete object['$type']\n\n      // Join key value pairs. Possibly use $type or constructor name\n      if (name == 'Object') {\n        return `{${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}}`\n      } else {\n        return `${name}({${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}})`\n      }\n    } else if (isNaN(object)) {\n      return 'NaN'\n    } else if (typeof object == 'number') {\n      // Number\n      return `${object}`\n    } else {\n      console.log(object, typeof object)\n      throw new Error('Stringify Error!')\n    }\n  }\n\n  /**\n   * Parse a string using the parser.\n   * @param  {ison string} string ison formatted string representing data.\n   * @throws {Error} If the data is incorrectly formatted.\n   * @return {Any}        the represented data\n   */\n  function parse(string) {\n    let p = new Parser(string)\n    let result = p.parseNext()\n    return result\n  }\n\n  // Module shim.\n  if(typeof module != \"undefined\") {\n    module.exports = { parse, stringify }\n  } else if (typeof window != \"undefined\") {\n    window['ISON'] = { parse, stringify }\n  }\n\n})();"]}