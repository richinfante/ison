{"version":3,"sources":["parser.js"],"names":["require","mod","name","_console","_len","arguments","length","args","Array","_key","DEBUG","console","log","apply","concat","debug","array","object","skip","types_debug","types","Date","Object","funcs","Int","parseInt","Float","Boolean","_Boolean","_x","this","toString","el","toLowerCase","Set","RegExp","Buffer","from","TOKEN_COMMA","TOKEN_WS","TOKEN_STRING_START","TOKEN_IDENTIFIER","TOKEN_IDENTIFIER_START","TOKEN_NUMBER_START","TOKEN_NUMBER","Parser","string","_classCallCheck","value","TOKEN_INFINITY","Infinity","stored","_createClass","key","TOKEN_FALSE","is","identifier","current","next","printError","charCodeAt","cur","num","substr","indexOf","parseFloat","start","out","push","parseNext","TOKEN_LBRACKET","parseString","parseNumber","parseIdentifier","TOKEN_COLON","TOKEN_LBRACE","parseArray","parseArguments","_toConsumableArray","TOKEN_LPAREN","TOKEN_RPAREN","TOKEN_ESCAPE","TOKEN_NEWLINE","TOKEN_BLOCK_COMMENT_END","Error","fromIdentifier","token","ret","TOKEN_RBRACE","test","error","undefined","l_bound","parseObject","u_bound","count","replace","newInstance","currentMatches","old","strict","peek","seek","get","stringifyKey","stringify","getTime","String","join","TOKEN_LINE_COMMENT","constructor","entries","source","flags","map","item","isNaN","_typeof","pprint","spacing","output","level","i","c","parse","module","exports","window"],"mappings":"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","file":"parser.js","sourcesContent":["/** \n * PV3 Experimental ISON Parser\n * This is designed to be ported into other languages, such as rust.\n * It will run faster there.\n *\n *\n * This parser is cursor based.\n * We have a finite set of tokens we should encounter at a specific index.\n * We can then use those to determine what to do next.\n * \n * For in-console debugging, set DEBUG env variable\n * For in-browser debugging, set DEBUG variable to true.\n */\n\n\n(function() {\n\n  // Require shim.\n  if (typeof require == \"undefined\") {\n    require = function(mod) {\n      if(mod == 'debug') {\n        return function(name) {\n          return function(...args) {\n            if(typeof DEBUG !=\"undefined\" && DEBUG) console.log(name, ...args)\n          }\n        }\n      }\n    }\n  }\n\n  const debug = {\n    log: require('debug')('parser:log'),\n    array: require('debug')('parser:array'),\n    object: require('debug')('parser:object'),\n    skip: require('debug')('parser:skip'),\n    string: require('debug')('parser:string'),\n  }\n\n  const types_debug = require('debug')('types')\n\n  // Type constructors\n  // Called with \"new\" to create an instance\n  const types = {\n    'Date': Date,\n    'Object': Object,\n    'Array': Array,\n    'Number': Number\n  }\n\n  // Functions\n  // Called normally with arguments to create instance.\n  const funcs = {\n    'Int': parseInt,\n    'Float': parseFloat,\n    'Boolean': el => new Boolean(el.toLowerCase() == 'true')\n  }\n\n  // Detect Map support\n  if (typeof Map != \"undefined\") {\n    types['Map'] = Map\n  }\n\n  // Detect Set support\n  if (typeof Set != \"undefined\") {\n    types['Set'] = Set\n  }\n\n  // Detect RegExp support\n  if (typeof RegExp != \"undefined\") {\n    types['RegExp'] = RegExp\n  }\n\n  // Detect if buffer.from is available.\n  if (typeof Buffer != \"undefined\") {\n    // If it is, check if Buffer.from() is supported.\n    if (typeof Buffer.from === \"function\") {\n      funcs['Buffer'] = Buffer.from\n    } else {\n      // Fallback to constructor.\n      types['Buffer'] = Buffer\n    }\n  }\n\n\n  function newInstance(name, args) {\n    types_debug('newInstance', name, args)\n\n    // Create a new instance using a constructor\n    if (types[name]) {\n      return new types[name](...args)\n    }\n    \n    // Create a new instance using functions\n    if (funcs[name]) {\n      return funcs[name](...args)\n    }\n    \n    \n    if (args.length == 1) {\n       return args[0]\n     } else {\n       return args\n     }\n    \n  }\n\n  // Tokens\n  const TOKEN_INFINITY = 'Infinity'\n  const TOKEN_NAN      = 'NaN'\n  const TOKEN_TRUE     = 'true'\n  const TOKEN_FALSE    = 'false'\n  const TOKEN_NULL     = 'null'\n  const TOKEN_LBRACE   = '{'\n  const TOKEN_RBRACE   = '}'\n  const TOKEN_LBRACKET = '['\n  const TOKEN_RBRACKET = ']'\n  const TOKEN_LPAREN   = '('\n  const TOKEN_RPAREN   = ')'\n  const TOKEN_SQUOTE   = `'`\n  const TOKEN_DQUOTE   = `\"`\n  const TOKEN_COMMA    = `,`\n  const TOKEN_COLON    = /[:=]/\n  const TOKEN_WS       = /[ \\n\\t]/\n  const TOKEN_STRING_START = /[\"']/\n  const TOKEN_IDENTIFIER = /[a-z0-9_]/i\n  const TOKEN_IDENTIFIER_START = /[a-z_]/i\n  const TOKEN_NUMBER_START = /[+0-9\\-]/\n  const TOKEN_NUMBER = /[0-9xbo\\.+\\-a-f]/i\n  const TOKEN_ESCAPE = '\\\\'\n  const TOKEN_NEWLINE = '\\n'\n  const TOKEN_LINE_COMMENT = '//'\n  const TOKEN_BLOCK_COMMENT_START = '/*'\n  const TOKEN_BLOCK_COMMENT_END = '*/'\n\n\n  // Convert an identifier into a primitive value.\n  function fromIdentifier(value) {\n\n    if (value == TOKEN_NULL) { \n      return null\n    }\n\n    if (value == TOKEN_INFINITY) { \n      return Infinity\n    }\n\n    if (value == TOKEN_NAN) { \n      return NaN\n    }\n\n    if (value == TOKEN_TRUE) { \n      return true\n    }\n\n    if (value == TOKEN_FALSE) { \n      return false\n    }\n\n    throw new Error('Unknown Identifier' + string)\n  }\n\n  class Parser {\n    constructor(string) {\n      this.cur = 0\n      this.string = string\n      this.stored = ''\n    }\n\n    /**\n     * Parse an identifier.\n     * @return {[type]} an identifier string.\n     */\n    parseIdentifier() {\n      this.skip(TOKEN_WS)\n\n      let identifier = ''\n\n      if (this.is(TOKEN_IDENTIFIER_START)) {\n        while (this.is(TOKEN_IDENTIFIER)) {\n          identifier += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      }\n\n      return identifier\n    }\n\n    /**\n     * Parse an identifier. These should be valid JS object keys.\n     * @return {number} The number that was parsed.\n     */\n    parseNumber() {\n      this.skip(TOKEN_WS)\n\n      let num = ''\n      if (this.is(TOKEN_NUMBER_START)) {\n        while (this.is(TOKEN_NUMBER)) {\n          num += this.current\n          this.next()\n        }\n      } else {\n        this.printError(`Unexpected token character ${this.current} (${this.current.charCodeAt(0)})`)\n      } \n\n      if(num.indexOf('0x') == 0) {\n        return parseInt(num.substr(2), 16)\n      } else if(num.indexOf('0b') == 0) {\n        return parseInt(num.substr(2), 2)\n      } else if(num.indexOf('0o') == 0) {\n        return parseInt(num.substr(2), 8)\n      }\n\n      return parseFloat(num)\n    }\n\n    /**\n     * Parse a string\n     * @return {string} the string that was parsed.\n     */\n    parseString() {\n      debug.string('Parsing String.')\n      if(!this.is(TOKEN_STRING_START)) {\n        this.printError('Invalid String start token')\n      }\n      \n      let start = this.current\n      this.skip(TOKEN_STRING_START, true, 1)\n      let out = ''\n\n\n      debug.string(`Entered string with \"${start}\" (${start.charCodeAt(0)})`)\n      \n      while(true) {\n        debug.string(`Have \"${this.current}\" (${this.current.charCodeAt(0)})`)\n        if(this.is(TOKEN_ESCAPE)) {\n          out += this.next()\n          debug.string('Got escape for', this.current)\n        } else if(this.is(start)) {\n          debug.string('End of string')\n          break\n        } else {\n          out += this.current\n          debug.string('Append', this.current)\n        }\n\n        this.next()\n      }\n\n      this.skip(TOKEN_STRING_START, true, 1)\n\n      debug.string(`output: \"${out}\"`)\n      return out\n    }\n\n    /**\n     * Parse an argument list\n     * @return {array} an array containing all the arguments.\n     */\n    parseArguments() {\n      this.skip(TOKEN_LPAREN, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RPAREN)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RPAREN)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RPAREN, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an array.\n     * @return {array} returns array items\n     */\n    parseArray() {\n      this.skip(TOKEN_LBRACKET, true, 1)\n      this.skip(TOKEN_WS)\n\n      let array = []\n      while(!this.is(TOKEN_RBRACKET)) {\n\n        this.skip(TOKEN_WS)\n\n        let value = this.parseNext()\n\n        array.push(value)\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACKET)) {\n          break\n        } else {\n          this.printError(`Unexpected token, \"${this.current}\" (${this.current.charCodeAt(0)}) looking for COMMA or RBRACKET.`)\n        }\n      }\n\n      this.skip(TOKEN_WS)\n      this.skip(TOKEN_RBRACKET, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an object notation block.\n     * @return {object} The represented object.\n     */\n    parseObject() {\n\n      debug.object('entering object.')\n\n      this.skip(TOKEN_LBRACE, true, 1)\n      this.skip(TOKEN_WS)\n\n      let object = {}\n\n      while(!this.is(TOKEN_RBRACE)) {\n        let key = null\n\n        this.skip(TOKEN_WS)\n\n        debug.object('parsing key')\n\n        // Allowing quoted keys, use quote opt. to figure out which.\n        if (this.is(TOKEN_STRING_START)) {\n          key = this.parseString()\n        } else if (this.is(TOKEN_NUMBER_START)) {\n          key = this.parseNumber()\n        } else {\n          key = this.parseIdentifier()\n        }\n\n        // Skip separator and WS\n        this.skip(TOKEN_WS)\n        this.skip(TOKEN_COLON, true, 1)\n        this.skip(TOKEN_WS)\n\n        debug.object('got key', key)\n\n        // Value can be anything, go next.\n        let value = this.parseNext()\n\n        debug.object('got value', value)\n\n        // Save the key\n        object[key] = value\n\n\n        this.skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (this.is(TOKEN_COMMA)) {\n          this.skip(TOKEN_COMMA, true, 1)\n        } else if (this.is(TOKEN_RBRACE)) {\n          break\n        } else {\n          this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)}), looking for COMMA or RBRACE.`)\n        }\n      }\n\n      this.skip(TOKEN_RBRACE, true, 1)\n\n      return object\n    }\n\n    /**\n     * Parse the next item.\n     * This is used to parse a value of any type \n     * @return {any} The value\n     */\n    parseNext() {\n      debug.log('parse next!')\n      this.skip(TOKEN_WS)\n\n      if (this.is(TOKEN_LBRACE)) {\n        return this.parseObject()\n      } else if (this.is(TOKEN_LBRACKET)) {\n        return this.parseArray()\n      } else if (this.is(TOKEN_LPAREN)) {\n        return this.parseArguments()\n      } else if (this.is(TOKEN_NUMBER_START)) {\n        return this.parseNumber()\n      } else if (this.is(TOKEN_STRING_START)) {\n        return this.parseString()\n      } else if (this.is(TOKEN_IDENTIFIER_START)){\n        let identifier = this.parseIdentifier()\n        if(this.is(TOKEN_LPAREN)) {\n          let args = this.parseArguments()\n          return newInstance(identifier, args)\n        } else {\n          return fromIdentifier(identifier)\n        }\n      } else {\n        this.printError(`Unexpected token \"${this.current}\" (${this.current.charCodeAt(0)})`)\n      }\n    }\n\n    is(token) {\n      let ret = false\n\n      if(token instanceof RegExp) {\n        ret = token.test(this.current)\n      } else {\n        ret = this.current == token\n      }\n\n      debug.log('check is', this.current, token, ret)\n      \n      return ret\n    }\n\n    get current() {\n      return this.string[this.cur]\n    }\n\n\n    printError(error='Unknown Error') {\n      let current = this.cur\n      let l_bound = current - 10\n      if(l_bound < 0) {\n        l_bound = 0\n      }\n\n      let u_bound = current + 10\n      if (u_bound >= this.string.length) {\n        u_bound = this.string.length - 1\n      }\n\n      let count = current - l_bound\n      console.log(this.string.substring(l_bound, u_bound).replace(/\\n/g, ' '))\n      console.log('^'.padStart(count + 1))\n      console.log('index:', this.cur)\n      \n      throw new Error(error)\n    }\n\n    next () {\n      this.cur += 1\n      if (this.cur > this.string.length) {\n        this.printError('Unexpected EOF!')\n      }\n      return this.current\n    }\n\n    peek() {\n      return this.string[this.cur + 1]\n    }\n\n    clear() {\n      this.stored = ''\n    }\n\n    getParsed() {\n      return this.stored\n    }\n\n\n    seek (token) {\n      while(!this.currentMatches(token)) {\n        this.next()\n        debug.skip('(seek) skipping', this.current)\n      }\n    }\n\n    currentMatches(token) {\n      if (token instanceof RegExp) {\n        return token.test(this.current)\n      } else {\n        return this.current == token\n      }\n    }\n\n    // SKIP any number of tokens.\n    skip(token, strict=false, count=Infinity) {\n      debug.skip('skipping', token)\n      let old = this.cur\n\n      // If we're in strict mode, fail immediately.\n      if (strict && !this.currentMatches(token)) {\n        this.printError(`expected token \"${token}\" got \"${this.current}\"!`)\n      }\n\n      // While it matches, continue.\n      while(this.currentMatches(token) && count > 0) {\n        this.cur += 1\n        count -= 1\n      }\n\n      debug.skip('skipped ahead', this.cur - old)\n\n      // If we're skipping whitespace, \n      // Perform a skip for comments as well, if the token matches.\n      if (token == TOKEN_WS) {\n        debug.skip('check comment seek')\n\n        // If we're on a line comment\n        if (this.current + this.peek() == TOKEN_LINE_COMMENT) {\n          // Seek past it\n          this.seek(TOKEN_NEWLINE)\n        }\n\n        // If we're on a block comment\n        if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_START) {\n          \n          while(true) {\n            // Seek to the next '*'  \n            this.seek('*')\n\n            // If it makes up a comment end, break.\n            if (this.current + this.peek() == TOKEN_BLOCK_COMMENT_END) {\n              break\n            } else {\n              // Otherwise, continue.\n              this.next()\n            }\n          }\n\n          // Skip past the end comment.\n          this.next()\n          this.next()\n        }\n\n        // If it's still whitespace, skip.\n        // TOKEN_WS can only handle one comment at a time.\n        if (this.is(TOKEN_WS)) {\n          this.skip(TOKEN_WS)\n        }\n      }\n    }\n  }\n\n  function stringifyKey(key) {\n    if(/^[a-zA-Z_][_a-zA-Z0-9]*$/.test(key)) {\n      return key\n    } else {\n      return stringify(key)\n    }\n  }\n\n\n  function stringify(object) {\n    if (object instanceof Date) {\n      // Serialize dates\n      return `Date(${object.getTime()})`\n    } else if (typeof object == 'string' || object instanceof String) {\n      // Place into double quoted (escaped) strings\n      return `\"${object.replace(/\"/g, '\\\\\"')}\"`\n    } else if (object instanceof Array) {\n      // Join the stringification of children\n      return `[${object.map(stringify).join(',')}]`\n    } else if(object.constructor.name == 'Set') {\n      return `Set(${stringify(Array.from(object))})`\n    } else if(object.constructor.name == 'Map') {\n      return `Map(${stringify(Array.from(object.entries()))})`\n    } else if (typeof Buffer != \"undefined\" && object instanceof Buffer) {\n      return `Buffer([${[...object]}])`\n    } else if(object instanceof RegExp){\n      return `RegExp(${stringify(object.source)}, ${stringify(object.flags)})`\n    } else if (typeof object == 'boolean') {\n      return `${object}`\n    } else if (object instanceof Object) {\n      let name = object['$type'] || object.constructor.name\n\n      delete object['$type']\n\n      // Join key value pairs. Possibly use $type or constructor name\n      if (name == 'Object') {\n        return `{${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}}`\n      } else {\n        return `${name}({${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}})`\n      }\n    } else if (isNaN(object)) {\n      return 'NaN'\n    } else if (typeof object == 'number') {\n      // Number\n      return `${object}`\n    } else {\n      console.log(object, typeof object)\n      throw new Error('Stringify Error!')\n    }\n  }\n\n  function pprint(string, spacing) {\n    let output = ''\n    let level = 0\n    spacing = spacing || '  '\n\n    for (let i = 0; i < string.length; i++) {\n      if (['{', '[', ','].indexOf(string[i]) > -1) {\n\n        output += string[i] + '\\n'\n\n        if (['{', '['].indexOf(string[i]) > -1) {\n          level += 1;\n        }\n\n        for (let c = 0; c < level; c++) {\n          output += spacing;\n        }\n\n      } else if (['}', ']'].indexOf(string[i]) > -1) {\n        level -= 1;\n        output += '\\n'\n        for (let c = 0; c < level; c++) {\n          output += spacing;\n        }\n\n        output += string[i]\n      } else {\n\n\n        if (string[i] != ' ') {\n          output += string[i]\n        }\n\n        if (string[i] == ':') {\n          output += ' '\n        }\n      } \n    }\n\n    return output\n  }\n\n\n  /**\n   * Parse a string using the parser.\n   * @param  {ison string} string ison formatted string representing data.\n   * @throws {Error} If the data is incorrectly formatted.\n   * @return {Any}        the represented data\n   */\n  function parse(string) {\n    let p = new Parser(string)\n    let result = p.parseNext()\n    return result\n  }\n\n  // Module shim.\n  if(typeof module != \"undefined\") {\n    module.exports = { parse, stringify, pprint }\n  } else if (typeof window != \"undefined\") {\n    window['ISON'] = { parse, stringify, pprint }\n  }\n\n})();"]}