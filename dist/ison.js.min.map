{"version":3,"sources":["ison.js"],"names":["TOKEN_LBRACKET","TOKEN_RBRACKET","TOKEN_LPAREN","TOKEN_RPAREN","TOKEN_SQUOTE","TOKEN_DQUOTE","TOKEN_COMMA","TOKEN_COLON","TOKEN_WS","TOKEN_LINE_COMMENT","Date","TOKEN_BLOCK_COMMENT_START","Object","TOKEN_BLOCK_COMMENT_END","Array","Number","funcs","Int","parseInt","Float","parseFloat","Boolean","_Boolean","_x","apply","this","arguments","toString","el","toLowerCase","addConstants","object","i","count","current","test","key","stringify","units","getTime","String","replace","map","join","name","constructor","undefined","Buffer","concat","_toConsumableArray","RegExp","source","flags","stringifyKey","item","destructed","destructor","entries","isNaN","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","_ref","value","_ref2","_slicedToArray","err","return","console","log","_typeof","Error","types","Map","Set","from","Infinity","true","false","NaN","exported_funcs","parse","string","cur","parseIdentifier","skip","identifier","is","TOKEN_IDENTIFIER_START","TOKEN_IDENTIFIER","printError","printFoundExpectedError","parseNumber","num","TOKEN_UNITS","TOKEN_NUMBER_START","TOKEN_NUMBER","substr","number","indexOf","start","TOKEN_STRING_START","out","nextChar","array","parseNext","push","parseObject","TOKEN_LBRACE","parseArray","parseArguments","parseString","args","Function","prototype","bind","token","strict","length","peek","seek","found","charCodeAt","expected","error","l_bound","u_bound","substring","padStart","addTypes","removeTypes","removeConstants","module","exports","window"],"mappings":"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","file":"ison.js","sourcesContent":["/*!\n * ISON v0.0.20\n * (c) 2018 Rich Infante\n * Released under the MIT License.\n */\n\n(function() {\n\n  \n\n  // Tokens\n  const TOKEN_INFINITY = 'Infinity'\n  const TOKEN_NAN      = 'NaN'\n  const TOKEN_TRUE     = 'true'\n  const TOKEN_FALSE    = 'false'\n  const TOKEN_NULL     = 'null'\n  const TOKEN_LBRACE   = '{'\n  const TOKEN_RBRACE   = '}'\n  const TOKEN_LBRACKET = '['\n  const TOKEN_RBRACKET = ']'\n  const TOKEN_LPAREN   = '('\n  const TOKEN_RPAREN   = ')'\n  const TOKEN_SQUOTE   = `'`\n  const TOKEN_DQUOTE   = `\"`\n  const TOKEN_COMMA    = `,`\n  const TOKEN_COLON    = /[:=]/\n  const TOKEN_WS       = /[ \\n\\t]/\n  const TOKEN_STRING_START = /[\"']/\n  const TOKEN_IDENTIFIER = /[\\$@~a-z0-9_\\.]/i\n  const TOKEN_IDENTIFIER_START = /[\\$@~a-z_]/i\n  const TOKEN_NUMBER_START = /[+0-9\\-]/\n  const TOKEN_NUMBER = /[0-9xbo\\.+\\-a-f]/i\n  const TOKEN_UNITS = /[%Î¼a-z/0-9_\\^]/i\n  const TOKEN_ESCAPE = '\\\\'\n  const TOKEN_NEWLINE = '\\n'\n  const TOKEN_LINE_COMMENT = '//'\n  const TOKEN_BLOCK_COMMENT_START = '/*'\n  const TOKEN_BLOCK_COMMENT_END = '*/'\n\n  // Type constructors\n  // Called with \"new\" to create an instance\n  const types = {\n    'Date': Date,\n    'Object': Object,\n    'Array': Array,\n    'Number': Number\n  }\n\n  // Functions\n  // Called normally with arguments to create instance.\n  const funcs = {\n    'Int': parseInt,\n    'Float': parseFloat,\n    'Boolean': el => new Boolean(el.toLowerCase() == 'true')\n  }\n\n  // Detect Map support\n  if (typeof Map != \"undefined\") {\n    types['Map'] = Map\n  }\n\n  // Detect Set support\n  if (typeof Set != \"undefined\") {\n    types['Set'] = Set\n  }\n\n  // Detect RegExp support\n  if (typeof RegExp != \"undefined\") {\n    types['RegExp'] = RegExp\n  }\n\n  // Detect if buffer.from is available.\n  if (typeof Buffer != \"undefined\") {\n    // If it is, check if Buffer.from() is supported.\n    if (typeof Buffer.from === \"function\") {\n      funcs['Buffer'] = Buffer.from\n    } else {\n      // Fallback to constructor.\n      types['Buffer'] = Buffer\n    }\n  }\n\n  /**\n   * Add types to the ISON parser.\n   * It will instantiate using them\n   * @param {object} object dictionary of object names and constructors.\n   */\n  function addTypes(object) {\n    for(let i in object) {\n      types[i] = object[i]\n    }\n  }\n\n  addConstants({\n    'null': null,\n    'Infinity': Infinity,\n    'true': true,\n    'false': false,\n    'NaN': NaN\n  })\n\n  /**\n   * Remove types from the ISON parser.\n   * It will remove them from the type index.\n   * @param {object} object dictionary of object names and constructors to remove..\n   */\n  function removeTypes(object) {\n    for (let i in object) {\n      if(types[i] === object[i]) {\n        delete types[i]\n      }\n    }\n  }\n\n    /**\n   * Add types to the ISON parser.\n   * It will instantiate using them\n   * @param {object} object dictionary of object names and constructors.\n   */\n  function addConstants(object) {\n    for(let i in object) {\n      funcs[i] = object[i]\n    }\n  }\n\n  /**\n   * Remove types from the ISON parser.\n   * It will remove them from the type index.\n   * @param {object} object dictionary of object names and constructors to remove..\n   */\n  function removeConstants(object) {\n    for (let i in object) {\n      if(funcs[i] === object[i]) {\n        delete funcs[i]\n      }\n    }\n  }\n\n  /**\n   * Parse a string using the parser.\n   * @param  {ison string} string ison formatted string representing data.\n   * @throws {Error} If the data is incorrectly formatted.\n   * @return {Any}        the represented data\n   */\n  function parse(string) {\n    var cur = 0\n\n\n    function newInstance(name, args) {\n\n      // Create a new instance using a constructor\n      if (types[name]) {\n        return new types[name](...args)\n      }\n      \n      // Create a new instance using functions\n      if (funcs[name] && typeof funcs[name] == 'function') {\n        return funcs[name](...args)\n      }\n      \n      printError(`Unknown type name: \"${name}\".`)\n    }\n\n    /**\n     * Convert an identifier into a primitive value.\n     * @param  {string} value a string representing some predefined value.\n     * @return {Any}       the represented value\n     * @throws {Error} If the value is not found.\n     */\n    function fromIdentifier(value) {\n\n      if (funcs[value] !== undefined) {\n        return funcs[value]\n      }\n\n      printError(`Unknown Identifier: \"${value}\"`)\n    }\n\n    /**\n     * Parse an identifier.\n     * @return {[type]} an identifier string.\n     */\n    function parseIdentifier() {\n      skip(TOKEN_WS)\n\n      let identifier = ''\n\n      if (is(TOKEN_IDENTIFIER_START)) {\n        while (is(TOKEN_IDENTIFIER)) {\n          identifier += current()\n          next(false)\n        }\n      } else {\n        printFoundExpectedError(current(), TOKEN_IDENTIFIER_START)\n      }\n\n      return identifier\n    }\n\n    function parseUnits() {\n      let units = ''\n      while(is(TOKEN_UNITS)) {\n        units += current()\n        next()\n      }\n\n      return units\n    }\n\n    /**\n     * Parse an identifier. These should be valid JS object keys.\n     * @return {number} The number that was parsed.\n     */\n    function parseNumber() {\n      skip(TOKEN_WS)\n\n      let num = ''\n      if (is(TOKEN_NUMBER_START)) {\n        while (is(TOKEN_NUMBER)) {\n          num += current()\n          next()\n        }\n\n        if(num == '-' || num == '+' && is(TOKEN_IDENTIFIER_START)) {\n          return (num == '-' ? -1 : 1) * parseIdentifier()\n        }\n\n      } else {\n        printFoundExpectedError(current(), TOKEN_NUMBER_START)\n      } \n\n      if(num.indexOf('0x') == 0) {\n        return parseInt(num.substr(2), 16)\n      } else if(num.indexOf('0b') == 0) {\n        return parseInt(num.substr(2), 2)\n      } else if(num.indexOf('0o') == 0) {\n        return parseInt(num.substr(2), 8)\n      }\n\n      skip(TOKEN_WS)\n\n      if (is(TOKEN_UNITS)) {\n        let units = parseUnits()\n        let number = new Number(parseFloat(num))\n        number.units = units\n        return number\n      }\n\n      return parseFloat(num)\n    }\n\n    /**\n     * Parse a string\n     * @return {string} the string that was parsed.\n     */\n    function parseString() {\n      if(!is(TOKEN_STRING_START)) {\n        printFoundExpectedError(current(), TOKEN_STRING_START)\n      }\n      \n      let start = current()\n      skip(TOKEN_STRING_START, true, 1)\n      let out = ''\n      \n      while(true) {\n        if(is(TOKEN_ESCAPE)) {\n          let nextChar = next()\n          if (nextChar == 'n') {\n            out += '\\n'\n          } else {\n            out += nextChar\n          }\n        } else if(is(start)) {\n          break\n        } else {\n          out += current()\n        }\n\n        next()\n      }\n\n      skip(TOKEN_STRING_START, true, 1)\n      return out\n    }\n\n    /**\n     * Parse an argument list\n     * @return {array} an array containing all the arguments.\n     */\n    function parseArguments() {\n      skip(TOKEN_LPAREN, true, 1)\n      skip(TOKEN_WS)\n\n      let array = []\n      while(!is(TOKEN_RPAREN)) {\n\n        skip(TOKEN_WS)\n\n        let value = parseNext()\n\n        array.push(value)\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RPAREN)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \")')\n        }\n      }\n\n      skip(TOKEN_WS)\n      skip(TOKEN_RPAREN, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an array.\n     * @return {array} returns array items\n     */\n    function parseArray() {\n      skip(TOKEN_LBRACKET, true, 1)\n      skip(TOKEN_WS)\n\n      let array = []\n      while(!is(TOKEN_RBRACKET)) {\n\n        skip(TOKEN_WS)\n\n        let value = parseNext()\n\n        array.push(value)\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RBRACKET)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \"]')\n        }\n      }\n\n      skip(TOKEN_WS)\n      skip(TOKEN_RBRACKET, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an object notation block.\n     * @return {object} The represented object.\n     */\n    function parseObject() {\n\n      skip(TOKEN_LBRACE, true, 1)\n      skip(TOKEN_WS)\n\n      let object = {}\n\n      while(!is(TOKEN_RBRACE)) {\n        let key = null\n\n        skip(TOKEN_WS)\n\n        // Allowing quoted keys, use quote opt. to figure out which.\n        if (is(TOKEN_STRING_START)) {\n          key = parseString()\n        } else if (is(TOKEN_NUMBER_START)) {\n          key = parseNumber()\n        } else {\n          key = parseIdentifier()\n        }\n\n        // Skip separator and WS\n        skip(TOKEN_WS)\n        skip(TOKEN_COLON, true, 1)\n        skip(TOKEN_WS)\n\n        // Value can be anything, go next.\n        let value = parseNext()\n\n        // Save the key\n        object[key] = value\n\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RBRACE)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \"}')\n        }\n      }\n\n      skip(TOKEN_RBRACE, true, 1);\n\n      return object\n    }\n\n    /**\n     * Parse the next item.\n     * This is used to parse a value of any type \n     * @return {any} The value\n     */\n    function parseNext() {\n      skip(TOKEN_WS)\n\n      if (is(TOKEN_LBRACE)) {\n        return parseObject()\n      } else if (is(TOKEN_LBRACKET)) {\n        return parseArray()\n      } else if (is(TOKEN_LPAREN)) {\n        return parseArguments()\n      } else if (is(TOKEN_NUMBER_START)) {\n        return parseNumber()\n      } else if (is(TOKEN_STRING_START)) {\n        return parseString()\n      } else if (is(TOKEN_IDENTIFIER_START)){\n        let identifier = parseIdentifier()\n        if(is(TOKEN_LPAREN)) {\n          let args = parseArguments()\n          return newInstance(identifier, args)\n        } else {\n          return fromIdentifier(identifier)\n        }\n      } else {\n        printFoundExpectedError(current())\n      }\n    }\n\n    this.parseNext = parseNext\n\n    /**\n     * Check if the current character is a token\n     * @param  {RegExp|string}  token a token description\n     * @return {Boolean}       does it match the current?\n     */\n    function is(token) {\n      if (current() == undefined) {\n        return false\n      } else if(token instanceof RegExp) {\n        return token.test(current())\n      } else {\n        return current() == token\n      }\n    }\n\n    /**\n     * Get the character under the cursor\n     * @return {string} the character\n     */\n    function current() {\n      return string[cur]\n    }\n\n    /**\n     * Advance the cursor and get the next value\n     * @throws {Error} If we need a next character and we found EOF.\n     * @return {string} the next character\n     */\n    function next (strict=true) {\n      cur += 1\n      if (strict && cur > string.length) {\n        printError('Unexpected EOF!')\n      }\n      return current()\n    }\n\n    /**\n     * Returns the next character in the input string.\n     * @return {string} next input character\n     */\n    function peek() {\n      return string[cur + 1]\n    }\n\n\n    /**\n     * Seek forward in the input for a specific token\n     * @param  {RegExp|string} token token to find.\n     */\n    function seek (token) {\n      while(!is(token) && current() != undefined) {\n        next()\n      }\n    }\n\n    /**\n     * Skip matching tokens.\n     * @param  {RegExp|String}  token  token to skip\n     * @param  {Boolean} strict should we fail if this cannot be found?\n     * @param  {Number}  count  skip a certain amount of tokens.\n     */\n    function skip(token, strict=false, count=Infinity) {\n      let old = cur\n\n      // If we're in strict mode, fail immediately.\n      if (strict && !is(token)) {\n        printFoundExpectedError(current(), token)\n      }\n\n      // While it matches, continue.\n      while (is(token) && count > 0) {\n        cur += 1\n        count -= 1\n      }\n\n      // If we're skipping whitespace, \n      // Perform a skip for comments as well, if the token matches.\n      if (token == TOKEN_WS) {\n\n        // If we're on a line comment\n        if (current() + peek() == TOKEN_LINE_COMMENT) {\n          // Seek past it\n          seek(TOKEN_NEWLINE)\n        }\n\n        // If we're on a block comment\n        if (current() + peek() == TOKEN_BLOCK_COMMENT_START) {\n          \n          while(true && current != undefined) {\n            // Seek to the next '*'  \n            seek('*')\n\n            // If it makes up a comment end, break.\n            if (current() + peek() == TOKEN_BLOCK_COMMENT_END) {\n              break\n            } else {\n              // Otherwise, continue.\n              next()\n            }\n          }\n\n          // Skip past the end comment.\n          next()\n          next()\n        }\n\n        // If it's still whitespace, skip.\n        // TOKEN_WS can only handle one comment at a time.\n        if (is(TOKEN_WS)) {\n          skip(TOKEN_WS)\n        }\n      }\n    }\n\n    function printFoundExpectedError(found, expected) {\n      printError(`Unexpected Token. found: \"${found}\" (${found.charCodeAt(0)}), expected: \"${expected}\"`)\n    }\n\n    /**\n     * Throw an error, internal use function.\n     * throws an error with source printout, error description.\n     * @throws {Error} If true\n     * @param  {String} error error description\n     */\n    function printError(error='Unknown Error') {\n      let current = cur\n      let l_bound = current - 10\n      if(l_bound < 0) {\n        l_bound = 0\n      }\n\n      let u_bound = current + 10\n      if (u_bound >= string.length) {\n        u_bound = string.length - 1\n      }\n\n      let count = current - l_bound\n\n      throw new Error(`Could not parse input.\n${string.substring(l_bound, u_bound).replace(/\\n/g, ' ')}\n${'^'.padStart(count + 1)}\n${error}\nat input: ${cur}`)\n    }\n\n    return parseNext()\n  }\n\n  /**\n   * Stringify a key.\n   * This may add quotes if it does not conform to bare key requirements.\n   * \n   * @param  {string} key the object key\n   * @return {string}     string representing the key.\n   */\n  function stringifyKey(key) {\n    if(/^[a-zA-Z_][_a-zA-Z0-9]*$/.test(key)) {\n      return key\n    } else {\n      return stringify(key)\n    }\n  }\n\n\n  /**\n   * Stringify an object, recursively\n   * @param  {object} object to stringify\n   * @return {string}        string representation\n   */\n  function stringify(object) {\n    if (object instanceof Number && object.units) {\n      return `${object} ${object.units}`\n    } else if(object === null || object === undefined) {\n      return 'null'\n    } else if (object instanceof Date) {\n      // Serialize dates\n      return `Date(${object.getTime()})`\n    } else if (typeof object == 'string' || object instanceof String) {\n      // Place into double quoted (escaped) strings\n      return `\"${object.replace(/\"/g, '\\\\\"')}\"`\n    } else if (object instanceof Array) {\n      // Join the stringification of children\n      return `[${object.map(stringify).join(',')}]`\n    } else if(object.constructor.name == 'Set') {\n      return `Set(${stringify(Array.from(object))})`\n    } else if(object.constructor.name == 'Map') {\n      return `Map(${stringify(Array.from(object.entries()))})`\n    } else if (typeof Buffer != \"undefined\" && object instanceof Buffer) {\n      return `Buffer([${[...object]}])`\n    } else if(object instanceof RegExp){\n      return `RegExp(${stringify(object.source)}, ${stringify(object.flags)})`\n    } else if (typeof object == 'boolean') {\n      return `${object}`\n    } else if (object instanceof Object) {\n      let name = object.className || object['$type'] || object.constructor.name\n\n      delete object['$type']\n\n      // Join key value pairs. Possibly use $type or constructor name\n      if (name == 'Object') {\n        return `{${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}}`\n      } else {\n        if (typeof object.destructor == 'function') {\n          let destructed = object.destructor()\n          if(destructed instanceof Array) {\n            return `${name}(${destructed.map(stringify).join(',')})`\n          } else {\n            return `${name}(${stringify(destructed)})`\n          }\n        } else {\n          return `${name}({${Object.entries(object).map((item) => {\n            return `${stringifyKey(item[0])}:${stringify(item[1])}`\n          }).join(',')}})`\n        }\n      }\n    } else if (isNaN(object)) {\n      return 'NaN'\n    } else if (typeof object == 'number') {\n      // Number\n      return `${object}`\n    } else {\n      for (let [key, value] of Object.entries(funcs)) {\n        if (value === object) {\n          return key\n        }\n      }\n      \n      console.log(object, typeof object)\n      throw new Error('Stringify Error!')\n    }\n  }\n\n  // Module shim.\n  var exported_funcs = { parse, stringify, addTypes, removeTypes, addConstants, removeConstants }\n\n  if(typeof module != \"undefined\") {\n    module.exports = exported_funcs\n  } else if (typeof window != \"undefined\") {\n    window['ISON'] = exported_funcs\n  }\n\n})();"]}