{"version":3,"sources":["ison.js"],"names":["types","Date","Object","Array","Number","funcs","Int","parseInt","Float","parseFloat","Boolean","_Boolean","_x","apply","this","arguments","toString","el","toLowerCase","Map","Set","RegExp","Buffer","from","TOKEN_NAN","TOKEN_TRUE","TOKEN_FALSE","TOKEN_NULL","TOKEN_LBRACE","TOKEN_RBRACE","TOKEN_LBRACKET","TOKEN_RBRACKET","stringifyKey","key","test","stringify","object","getTime","String","replace","join","constructor","name","entries","concat","_toConsumableArray","source","flags","map","item","isNaN","_typeof","Error","exported_funcs","parse","TOKEN_NEWLINE","TOKEN_LINE_COMMENT","value","skip","TOKEN_WS","identifier","is","TOKEN_IDENTIFIER_START","TOKEN_IDENTIFIER","current","next","printFoundExpectedError","parseNumber","num","TOKEN_NUMBER","TOKEN_NUMBER_START","indexOf","substr","parseString","TOKEN_STRING_START","start","out","charCodeAt","debug","array","parseNext","TOKEN_LPAREN","TOKEN_COMMA","parseObject","parseArray","log","args","parseArguments","Function","prototype","bind","newInstance","Infinity","fromIdentifier","printError","token","string","cur","length","peek","strict","undefined","count","seek","found","expected","error","l_bound","u_bound","substring","padStart","console","module","exports","window"],"mappings":"6WAmBA,WAKE,IAAMA,EAAQ,CALfC,KAAAA,KAOGC,OAAUA,OAJZC,MAAAA,MACAC,OAAAA,QAKEC,EAAUD,CAMVE,IAAOC,SAHTC,MAAAC,WACAC,QAAA,SAAAC,GAAA,SAAAD,EAAAE,GAAA,OAAAD,EAAAE,MAAAC,KAAAC,WAAA,OAAAL,EAAAM,SAAA,WAAA,OAAAL,EAAAK,YAAAN,EAAA,CAAA,SAAAO,GAAA,OAAA,IAAAP,QAAA,QAAAO,EAAAC,kBAIE,oBAAAC,MAAAnB,EAAA,IAAAmB,KAAA,oBAAAC,MAAApB,EAAA,IAAAoB,KAAW,oBAAAC,SAAArB,EAAA,OAAUU,QAIL,oBAAdY,SAEH,mBAAAA,OAAAC,KAgBGlB,EAAA,OAAkBiB,OAAOC,KAZ3BvB,EAAAA,OAAAsB,QA6BA,IAeIE,EAAAA,IACAC,EAAN,OACMC,EAAiB,UACjBC,EAAN,OACMC,EAAN,aACMC,EAAN,UACMC,EAAN,WACMC,EAAiB,oBA+ctB,SAAAC,EAAAC,GAUC,MAAG,2BAA2BC,KAAKD,GARrCA,EAWWE,EAAUF,GAClB,SAAAE,EAAAC,GACF,GAAAA,aAAAnC,KAGD,MAAA,QAAAmC,EAAAC,UAAA,IASS,GAAqB,iBAAVD,GAAsBA,aAAkBE,OAExD,MAAA,IAAWF,EAAOG,QAAQ,KAAM,OAAhC,IACK,GAAIH,aAAkBjC,MAN7B,MAAA,IAAIiC,EAAAA,IAAkBnC,GAAMuC,KAAA,KAA5B,IACE,GAAA,OAAAJ,EAAAK,YAAAC,KACA,MAAA,OAAAP,EAAsBE,MAAAA,KAAtBD,IAAA,IACK,GAAI,OAAJA,EAAIK,YAAiBC,KAC1B,MAAA,OAAAP,EAAAhC,MAAAoB,KAAAa,EAAAO,YAAA,IACA,GAAkBJ,oBAAPH,QAAXA,aAAAd,OAFK,MAAA,WAAA,GAAAsB,OAAAC,mBAGIT,IAHJ,KAIL,GAAAA,aAAAf,OACA,MAAA,UAAWe,EAAWD,EAAXW,QAAX,KAAAX,EAAAC,EAAAW,OAAA,IACK,GAAUN,kBAAAA,EACf,MAAA,GAAAL,EACK,GAAGA,aAAAlC,OAAA,CACR,IAAAwC,EAAAN,EAAA,OAAwBjC,EAAWiC,YAAOO,KAGrC,cADLP,EAAA,MAGS,UAFJM,EAGL,IAAUN,OAAVO,QAAAP,GAAAY,IAAA,SAAAC,GADK,OAEIb,EAAkBlC,EAAAA,IAFtB,IAE8BiC,EAAAc,EAAA,MAC/BP,KAAAA,KAFJ,IAION,EAAP,KAAOlC,OAAPyC,QAAAP,GAAAY,IAAA,SAAAC,GASI,OAAUjB,EAAaiB,EAAK,IAA5B,IAAmCd,EAAUc,EAAK,MAPtDT,KAAA,KAFA,KAIE,GAAAU,MAAWhD,GACT,MAAA,MACCsC,GAFH,iBAAAJ,EAIA,MAAA,GAAUM,EAGX,WADE,IAFDN,GAECe,QAFDf,GAGD,IAAAgB,MAAA,oBAKD,IAAAC,EAAUjB,CAAVkB,MA/fJ,SAAMC,GACN,IAAMC,EAAAA,EAsCF,SAAIC,IACFC,EAAAC,GAaF,IAAIC,EAAa,GATlB,GAAAC,EAAAC,GAYG,KAAOD,EAAGE,IAVdH,GAAAI,IAYMC,SARNC,EAA2BF,IAAAF,GAGzB,OAAIF,EAOH,SAAMO,IACLD,EAAAA,GAaF,IAAIE,EAAM,GAVV,GAAAP,EAAOD,GACR,KAAAC,EAAAQ,IAYKD,GAAOJ,IAVbC,SAcIC,EAAwBF,IAAWM,GAGrC,OAAwB,GAArBF,EAAIG,QAAQ,MAVXH,SAAJA,EAAAI,OAAA,GAAA,IAC4B,GAArBF,EAAAA,QAAAA,MACET,SAAGQ,EAAAA,OAAe,GAAA,GACvB,GAAAD,EAAOJ,QAAP,MACAC,SAAAA,EAAAA,OAAAA,GAAAA,GAGFC,WAAAA,GAOD,SAAMO,IAENZ,EAAAa,IAYCR,EAAwBF,IAAWU,GAGrC,IAAIC,EAAQX,IAVdN,EAAAgB,GAAA,EAAA,GAYE,IAAIE,EAAM,GANV,IAFqBD,EAAAE,WAAA,KAEdH,CAEN,GADCR,IAAmCQ,IAAAA,WAAnC,GACDb,EApHkB,MAgIfe,GAAOX,IAVXD,QACKU,CAAAA,GAAAA,EAAAA,GAaD,MAEAE,GAAOZ,IATCA,IAGRY,IAMAA,OAHAE,EAAAA,GAAa,EAAA,GAGbF,EAOJlB,SAAKgB,IAWLhB,EApKH,KAoKsB,EAAM,GATzBoB,EAAAA,GAaA,IAXD,IAAAC,EAAA,IAWQlB,EA3JY,MA2JM,CAEvBH,EAAKC,GAEL,IAAIF,EAAQuB,IAOZ,GAfFtB,EAAKuB,KAAAA,GAYHvB,EAAKC,GAGDE,EAAGqB,GATPxB,EAAKC,GAAL,EAAA,OAWO,CAAA,GAAIE,EAxKM,KA+JjB,MAEAkB,EAAAf,IAAA,aAOC,OAHDN,EAAAC,GACAD,EAtKiB,KAsKVwB,EAAc,GAArBH,EAqHJ,SAASC,IALT,GAFCtB,EAAAC,GAEDE,EAxSG,KAkTC,OA9EFH,WAIDA,EAxOE,KAwOF,EAAA,GAWCA,EAAKC,GAIL,IAFA,IAAIvB,EAAS,IAENyB,EAtPD,MAsPmB,CAT3B,IAAA5B,EAASkD,KAEPL,EAAM1C,GAgBFH,EAXAG,EAAAA,GAWMqC,IATA5C,EAAAA,GACJI,IAEC0B,IAILD,EAAAC,GACAD,EAAIG,GAAGa,EAAAA,GACLzC,EAAAA,GAKD,IAAAwB,EAAAuB,IAqBD,GAhBAtB,EAAKC,GAALF,EAaAC,EAAKC,GAGDE,EAAGqB,GATPJ,EAAM1C,GAAO,EAAaqB,OAWnB,CAAA,GAAII,EA3RP,KAkRJ,MAYEK,EAAwBF,IAAW,aAHpC,OAFDN,EAzRI,KAyRGwB,EAAc,GAArB9C,EAwBO+C,GACF,GAAItB,EAjTV,KAkTC,OAnHFH,WACAA,EAhMC,KAgMkB,EAAnB,GAWAA,EAAKC,GAGL,IAXD,IAAAoB,EAAA,IAWQlB,EA7MP,MA6M2B,CAEzBH,EAAKC,GAEL,IAAIF,EAAQuB,IAOZ,GAfFtB,EAAK5B,KAAAA,GAYH4B,EAAKC,GAGDE,EAAGqB,GATPxB,EAAKC,GAAL,EAAA,OAWO,CAAA,GAAIE,EA1Nb,KAiNE,MAEAkB,EAAAf,IAAA,aAOC,OAHDN,EAAAC,GACAD,EAxNF,KAwNE,EAAqB,GAArBqB,EAyFOK,GACF,GAAIvB,EAhTd,KAwSC,OAASmB,IACDK,GAAIxB,EAAAS,GACVZ,OAAKC,IAUE,GAAIE,EAAGa,GARd,OAAO9C,IACL,GAAOuD,EAAAA,GAAP,CADF,IAAAvB,EAEc9B,IACZ,GAAA+B,EA/SL,KA+SK,CADK,IAEAyB,EAAOL,IACZ,OApVJK,EAoVIA,EAhVFtF,EAJgBqB,EAoVPkE,GA/UX,IAAAC,SAAAC,UAAAC,KAAA7E,MAAAb,EAAA0C,GAAA,CAAA,MAAAE,OAAAC,mBAAAyC,MAIEjF,EAAAqC,GACMrC,EAAAqC,GAAA7B,MAAAR,EAAAwC,mBAAYvB,IAKDoB,GAArB4C,EAASK,OACD3F,EAAM,GAEZsF,EAoUI,MAzTJ,SAoDwB7B,EAqQpBG,GA7QJ,KAjDiB,YA+DXH,EACKmC,EAAAA,EA/DF,OAkEHnC,EAVGoC,IAvDR,QA0DGpC,GA3CiB,SA+CjBA,QAIAqC,EAAAA,wBAAArC,EAAA,KAXJ,IAAwBA,EAjFNpC,EAAlBiE,EAuVSpB,EAEOJ,KAWf,SAAAD,EAAAkC,GAUC,OAAGA,aAAiB1E,OARjB2D,EAAYA,KAAAA,KAEjBhB,KAAA+B,EAQG,SAAM/B,IACL,OAAAgC,EAAOhC,GAQX,SAASA,IAcP,OAbAiC,GAAOD,GACRA,EAAAE,QAUGJ,EAAW,mBAEN9B,IAFL8B,SAAAA,IACD,OAAAE,EAAAC,EAAA,GAQH,SAASE,EAATJ,GACE,MAAOC,EAAAA,IACR/B,IAUiCD,IAEjC,SAAAN,EAAAqC,GAAA,IAAAK,EAAA,EAAArF,UAAAmF,aAAAG,IAAAtF,UAAA,IAAAA,UAAA,GAAAuF,EAAA,EAAAvF,UAAAmF,aAAAG,IAAAtF,UAAA,GAAAA,UAAA,GAAA6E,EAAAA,EAQkD,IAK7CQ,IAAWvC,EAAGkC,IAChB7B,EAAwBF,IAAW+B,GANJO,EAAgBP,IAAA,EAAAO,GAW/CL,GAAO,EAVTnB,GAAW,EAkBX,GAAIiB,GAASpC,EAAU,CADvB,GANE2C,IAAAH,KA/XN,MA4YQI,EA7YR,MAsYIvC,IAAAmC,KApYJ,KAoYI,CAEErB,KAEAyB,EAAA,KAGOhD,IAAL4C,KA1YR,MA8YUnC,IAgBFC,IAVEA,IAKEA,EAAAA,IACDP,EAAAC,IAKHM,SAAAA,EAAAA,EAAAA,GACD6B,EAAAA,6BAAAU,EAAA,MAAAA,EAAA3B,WAAA,GAAA,iBAAA4B,EAAA,KAoBL,SAASX,IAAkC,IAAvBY,EAAuB,EAAA3F,UAAAmF,aAAAG,IAAAtF,UAAA,GAAAA,UAAA,GAAjB,gBAV1BiD,EAASE,EACP4B,EAAAA,EAAAA,GACDa,EAAA,IAYGA,EAAU,GAGZ,IAAIC,EAAU5C,EAAU,GACpB4C,GAAWZ,EAAOE,SACpBU,EAAUZ,EAAOE,OAAS,GATa,IAAvBQ,EAAuB1C,EAAA2C,EACzC,MAAI3C,IAAAA,MAAAA,2BACJgC,EAAAa,UAAIF,EAAU3C,GAAdzB,QAAA,MAAA,KADIyB,KAEJ,IAAA8C,SAAGH,EAAa,GAFZ3C,KAGF2C,EAHE3C,eAIHiC,GAGD,OAlJInF,KAAAkE,UAAOW,MA8NXxD,UAAAA,GAEYC,oBAAZ2E,OACAC,OAAAC,QAAM5D,EACP,oBAAA6D,SACFA,OAAA,KAAA7D,GAhmBH","file":"ison.js","sourcesContent":["/*!\n * ISON v0.0.11\n * (c) 2018 Rich Infante\n * Released under the MIT License.\n */\n/** \n * PV3 Experimental ISON Parser\n * This is designed to be ported into other languages, such as rust.\n * It will run faster there.\n *\n *\n * This parser is cursor based.\n * We have a finite set of tokens we should encounter at a specific index.\n * We can then use those to determine what to do next.\n * \n * For in-console debugging, set DEBUG env variable\n * For in-browser debugging, set DEBUG variable to true.\n */\n\n(function() {\n\n  \n  // Type constructors\n  // Called with \"new\" to create an instance\n  const types = {\n    'Date': Date,\n    'Object': Object,\n    'Array': Array,\n    'Number': Number\n  }\n\n  // Functions\n  // Called normally with arguments to create instance.\n  const funcs = {\n    'Int': parseInt,\n    'Float': parseFloat,\n    'Boolean': el => new Boolean(el.toLowerCase() == 'true')\n  }\n\n  // Detect Map support\n  if (typeof Map != \"undefined\") {\n    types['Map'] = Map\n  }\n\n  // Detect Set support\n  if (typeof Set != \"undefined\") {\n    types['Set'] = Set\n  }\n\n  // Detect RegExp support\n  if (typeof RegExp != \"undefined\") {\n    types['RegExp'] = RegExp\n  }\n\n  // Detect if buffer.from is available.\n  if (typeof Buffer != \"undefined\") {\n    // If it is, check if Buffer.from() is supported.\n    if (typeof Buffer.from === \"function\") {\n      funcs['Buffer'] = Buffer.from\n    } else {\n      // Fallback to constructor.\n      types['Buffer'] = Buffer\n    }\n  }\n\n\n  function newInstance(name, args) {\n    debug.types('newInstance', name, args)\n\n    // Create a new instance using a constructor\n    if (types[name]) {\n      return new types[name](...args)\n    }\n    \n    // Create a new instance using functions\n    if (funcs[name]) {\n      return funcs[name](...args)\n    }\n    \n    \n    if (args.length == 1) {\n       return args[0]\n     } else {\n       return args\n     }\n    \n  }\n\n  // Tokens\n  const TOKEN_INFINITY = 'Infinity'\n  const TOKEN_NAN      = 'NaN'\n  const TOKEN_TRUE     = 'true'\n  const TOKEN_FALSE    = 'false'\n  const TOKEN_NULL     = 'null'\n  const TOKEN_LBRACE   = '{'\n  const TOKEN_RBRACE   = '}'\n  const TOKEN_LBRACKET = '['\n  const TOKEN_RBRACKET = ']'\n  const TOKEN_LPAREN   = '('\n  const TOKEN_RPAREN   = ')'\n  const TOKEN_SQUOTE   = `'`\n  const TOKEN_DQUOTE   = `\"`\n  const TOKEN_COMMA    = `,`\n  const TOKEN_COLON    = /[:=]/\n  const TOKEN_WS       = /[ \\n\\t]/\n  const TOKEN_STRING_START = /[\"']/\n  const TOKEN_IDENTIFIER = /[a-z0-9_]/i\n  const TOKEN_IDENTIFIER_START = /[a-z_]/i\n  const TOKEN_NUMBER_START = /[+0-9\\-]/\n  const TOKEN_NUMBER = /[0-9xbo\\.+\\-a-f]/i\n  const TOKEN_ESCAPE = '\\\\'\n  const TOKEN_NEWLINE = '\\n'\n  const TOKEN_LINE_COMMENT = '//'\n  const TOKEN_BLOCK_COMMENT_START = '/*'\n  const TOKEN_BLOCK_COMMENT_END = '*/'\n\n\n  /**\n   * Parse a string using the parser.\n   * @param  {ison string} string ison formatted string representing data.\n   * @throws {Error} If the data is incorrectly formatted.\n   * @return {Any}        the represented data\n   */\n  function parse(string) {\n    var cur = 0\n\n    /**\n     * Convert an identifier into a primitive value.\n     * @param  {string} value a string representing some predefined value.\n     * @return {Any}       the represented value\n     * @throws {Error} If the value is not found.\n     */\n    function fromIdentifier(value) {\n\n      if (value == TOKEN_NULL) { \n        return null\n      }\n\n      if (value == TOKEN_INFINITY) { \n        return Infinity\n      }\n\n      if (value == TOKEN_NAN) { \n        return NaN\n      }\n\n      if (value == TOKEN_TRUE) { \n        return true\n      }\n\n      if (value == TOKEN_FALSE) { \n        return false\n      }\n\n      printError(`Unknown Identifier: \"${value}\"`)\n    }\n\n    /**\n     * Parse an identifier.\n     * @return {[type]} an identifier string.\n     */\n    function parseIdentifier() {\n      skip(TOKEN_WS)\n\n      let identifier = ''\n\n      if (is(TOKEN_IDENTIFIER_START)) {\n        while (is(TOKEN_IDENTIFIER)) {\n          identifier += current()\n          next()\n        }\n      } else {\n        printFoundExpectedError(current(), TOKEN_IDENTIFIER_START)\n      }\n\n      return identifier\n    }\n\n    /**\n     * Parse an identifier. These should be valid JS object keys.\n     * @return {number} The number that was parsed.\n     */\n    function parseNumber() {\n      skip(TOKEN_WS)\n\n      let num = ''\n      if (is(TOKEN_NUMBER_START)) {\n        while (is(TOKEN_NUMBER)) {\n          num += current()\n          next()\n        }\n      } else {\n        printFoundExpectedError(current(), TOKEN_NUMBER_START)\n      } \n\n      if(num.indexOf('0x') == 0) {\n        return parseInt(num.substr(2), 16)\n      } else if(num.indexOf('0b') == 0) {\n        return parseInt(num.substr(2), 2)\n      } else if(num.indexOf('0o') == 0) {\n        return parseInt(num.substr(2), 8)\n      }\n\n      return parseFloat(num)\n    }\n\n    /**\n     * Parse a string\n     * @return {string} the string that was parsed.\n     */\n    function parseString() {\n      debug.string('Parsing String.')\n      if(!is(TOKEN_STRING_START)) {\n        printFoundExpectedError(current(), TOKEN_STRING_START)\n      }\n      \n      let start = current()\n      skip(TOKEN_STRING_START, true, 1)\n      let out = ''\n\n\n      debug.string(`Entered string with \"${start}\" (${start.charCodeAt(0)})`)\n      \n      while(true) {\n        debug.string(`Have \"${current()}\" (${current().charCodeAt(0)})`)\n        if(is(TOKEN_ESCAPE)) {\n          out += next()\n          debug.string('Got escape for', current())\n        } else if(is(start)) {\n          debug.string('End of string')\n          break\n        } else {\n          out += current()\n          debug.string('Append', current())\n        }\n\n        next()\n      }\n\n      skip(TOKEN_STRING_START, true, 1)\n\n      debug.string(`output: \"${out}\"`)\n      return out\n    }\n\n    /**\n     * Parse an argument list\n     * @return {array} an array containing all the arguments.\n     */\n    function parseArguments() {\n      skip(TOKEN_LPAREN, true, 1)\n      skip(TOKEN_WS)\n\n      let array = []\n      while(!is(TOKEN_RPAREN)) {\n\n        skip(TOKEN_WS)\n\n        let value = parseNext()\n\n        array.push(value)\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RPAREN)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \")')\n        }\n      }\n\n      skip(TOKEN_WS)\n      skip(TOKEN_RPAREN, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an array.\n     * @return {array} returns array items\n     */\n    function parseArray() {\n      skip(TOKEN_LBRACKET, true, 1)\n      skip(TOKEN_WS)\n\n      let array = []\n      while(!is(TOKEN_RBRACKET)) {\n\n        skip(TOKEN_WS)\n\n        let value = parseNext()\n\n        array.push(value)\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RBRACKET)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \"]')\n        }\n      }\n\n      skip(TOKEN_WS)\n      skip(TOKEN_RBRACKET, true, 1)\n\n      return array\n    }\n\n    /**\n     * Parse an object notation block.\n     * @return {object} The represented object.\n     */\n    function parseObject() {\n\n      debug.object('entering object.')\n\n      skip(TOKEN_LBRACE, true, 1)\n      skip(TOKEN_WS)\n\n      let object = {}\n\n      while(!is(TOKEN_RBRACE)) {\n        let key = null\n\n        skip(TOKEN_WS)\n\n        debug.object('parsing key')\n\n        // Allowing quoted keys, use quote opt. to figure out which.\n        if (is(TOKEN_STRING_START)) {\n          key = parseString()\n        } else if (is(TOKEN_NUMBER_START)) {\n          key = parseNumber()\n        } else {\n          key = parseIdentifier()\n        }\n\n        // Skip separator and WS\n        skip(TOKEN_WS)\n        skip(TOKEN_COLON, true, 1)\n        skip(TOKEN_WS)\n\n        debug.object('got key', key)\n\n        // Value can be anything, go next.\n        let value = parseNext()\n\n        debug.object('got value', value)\n\n        // Save the key\n        object[key] = value\n\n\n        skip(TOKEN_WS)\n\n        // Comma or RBRACE are exit conditions.\n        if (is(TOKEN_COMMA)) {\n          skip(TOKEN_COMMA, true, 1)\n        } else if (is(TOKEN_RBRACE)) {\n          break\n        } else {\n          printFoundExpectedError(current(), ',\" or \"}')\n        }\n      }\n\n      skip(TOKEN_RBRACE, true, 1);\n\n      return object\n    }\n\n    /**\n     * Parse the next item.\n     * This is used to parse a value of any type \n     * @return {any} The value\n     */\n    function parseNext() {\n      debug.log('parse next!')\n      skip(TOKEN_WS)\n\n      if (is(TOKEN_LBRACE)) {\n        return parseObject()\n      } else if (is(TOKEN_LBRACKET)) {\n        return parseArray()\n      } else if (is(TOKEN_LPAREN)) {\n        return parseArguments()\n      } else if (is(TOKEN_NUMBER_START)) {\n        return parseNumber()\n      } else if (is(TOKEN_STRING_START)) {\n        return parseString()\n      } else if (is(TOKEN_IDENTIFIER_START)){\n        let identifier = parseIdentifier()\n        if(is(TOKEN_LPAREN)) {\n          let args = parseArguments()\n          return newInstance(identifier, args)\n        } else {\n          return fromIdentifier(identifier)\n        }\n      } else {\n        printFoundExpectedError(current())\n      }\n    }\n\n    this.parseNext = parseNext\n\n    /**\n     * Check if the current character is a token\n     * @param  {RegExp|string}  token a token description\n     * @return {Boolean}       does it match the current?\n     */\n    function is(token) {\n      if(token instanceof RegExp) {\n        return token.test(current())\n      } else {\n        return current() == token\n      }\n    }\n\n    /**\n     * Get the character under the cursor\n     * @return {string} the character\n     */\n    function current() {\n      return string[cur]\n    }\n\n    /**\n     * Advance the cursor and get the next value\n     * @throws {Error} If we need a next character and we found EOF.\n     * @return {string} the next character\n     */\n    function next () {\n      cur += 1\n      if (cur > string.length) {\n        printError('Unexpected EOF!')\n      }\n      return current()\n    }\n\n    /**\n     * Returns the next character in the input string.\n     * @return {string} next input character\n     */\n    function peek() {\n      return string[cur + 1]\n    }\n\n\n    /**\n     * Seek forward in the input for a specific token\n     * @param  {RegExp|string} token token to find.\n     */\n    function seek (token) {\n      while(!is(token)) {\n        next()\n        debug.skip('(seek) skipping', current())\n      }\n    }\n\n    /**\n     * Skip matching tokens.\n     * @param  {RegExp|String}  token  token to skip\n     * @param  {Boolean} strict should we fail if this cannot be found?\n     * @param  {Number}  count  skip a certain amount of tokens.\n     */\n    function skip(token, strict=false, count=Infinity) {\n      debug.skip('skipping', token)\n      let old = cur\n\n      // If we're in strict mode, fail immediately.\n      if (strict && !is(token)) {\n        printFoundExpectedError(current(), token)\n      }\n\n      // While it matches, continue.\n      while(is(token) && count > 0) {\n        cur += 1\n        count -= 1\n      }\n\n      debug.skip('skipped ahead', cur - old)\n\n      // If we're skipping whitespace, \n      // Perform a skip for comments as well, if the token matches.\n      if (token == TOKEN_WS) {\n        debug.skip('check comment seek')\n\n        // If we're on a line comment\n        if (current() + peek() == TOKEN_LINE_COMMENT) {\n          // Seek past it\n          seek(TOKEN_NEWLINE)\n        }\n\n        // If we're on a block comment\n        if (current() + peek() == TOKEN_BLOCK_COMMENT_START) {\n          \n          while(true) {\n            // Seek to the next '*'  \n            seek('*')\n\n            // If it makes up a comment end, break.\n            if (current() + peek() == TOKEN_BLOCK_COMMENT_END) {\n              break\n            } else {\n              // Otherwise, continue.\n              next()\n            }\n          }\n\n          // Skip past the end comment.\n          next()\n          next()\n        }\n\n        // If it's still whitespace, skip.\n        // TOKEN_WS can only handle one comment at a time.\n        if (is(TOKEN_WS)) {\n          skip(TOKEN_WS)\n        }\n      }\n    }\n\n    function printFoundExpectedError(found, expected) {\n      printError(`Unexpected Token. found: \"${found}\" (${found.charCodeAt(0)}), expected: \"${expected}\"`)\n    }\n\n    /**\n     * Throw an error, internal use function.\n     * throws an error with source printout, error description.\n     * @throws {Error} If true\n     * @param  {String} error error description\n     */\n    function printError(error='Unknown Error') {\n      let current = cur\n      let l_bound = current - 10\n      if(l_bound < 0) {\n        l_bound = 0\n      }\n\n      let u_bound = current + 10\n      if (u_bound >= string.length) {\n        u_bound = string.length - 1\n      }\n\n      let count = current - l_bound\n\n      throw new Error(`Could not parse input.\n${string.substring(l_bound, u_bound).replace(/\\n/g, ' ')}\n${'^'.padStart(count + 1)}\n${error}\nat input: ${cur}`)\n    }\n\n    return parseNext()\n  }\n\n  /**\n   * Stringify a key.\n   * This may add quotes if it does not conform to bare key requirements.\n   * \n   * @param  {string} key the object key\n   * @return {string}     string representing the key.\n   */\n  function stringifyKey(key) {\n    if(/^[a-zA-Z_][_a-zA-Z0-9]*$/.test(key)) {\n      return key\n    } else {\n      return stringify(key)\n    }\n  }\n\n\n  /**\n   * Stringify an object, recursively\n   * @param  {object} object to stringify\n   * @return {string}        string representation\n   */\n  function stringify(object) {\n    if (object instanceof Date) {\n      // Serialize dates\n      return `Date(${object.getTime()})`\n    } else if (typeof object == 'string' || object instanceof String) {\n      // Place into double quoted (escaped) strings\n      return `\"${object.replace(/\"/g, '\\\\\"')}\"`\n    } else if (object instanceof Array) {\n      // Join the stringification of children\n      return `[${object.map(stringify).join(',')}]`\n    } else if(object.constructor.name == 'Set') {\n      return `Set(${stringify(Array.from(object))})`\n    } else if(object.constructor.name == 'Map') {\n      return `Map(${stringify(Array.from(object.entries()))})`\n    } else if (typeof Buffer != \"undefined\" && object instanceof Buffer) {\n      return `Buffer([${[...object]}])`\n    } else if(object instanceof RegExp){\n      return `RegExp(${stringify(object.source)}, ${stringify(object.flags)})`\n    } else if (typeof object == 'boolean') {\n      return `${object}`\n    } else if (object instanceof Object) {\n      let name = object['$type'] || object.constructor.name\n\n      delete object['$type']\n\n      // Join key value pairs. Possibly use $type or constructor name\n      if (name == 'Object') {\n        return `{${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}}`\n      } else {\n        return `${name}({${Object.entries(object).map((item) => {\n          return `${stringifyKey(item[0])}:${stringify(item[1])}`\n        }).join(',')}})`\n      }\n    } else if (isNaN(object)) {\n      return 'NaN'\n    } else if (typeof object == 'number') {\n      // Number\n      return `${object}`\n    } else {\n      console.log(object, typeof object)\n      throw new Error('Stringify Error!')\n    }\n  }\n\n  // Module shim.\n  var exported_funcs = { parse, stringify }\n\n  if(typeof module != \"undefined\") {\n    module.exports = exported_funcs\n  } else if (typeof window != \"undefined\") {\n    window['ISON'] = exported_funcs\n  }\n\n})();"]}